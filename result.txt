spen on file samples/ls/ls-en-01.smt
init ta_symbol.
init entl.
  > parse file samples/ls/ls-en-01.smt
noll_mk_context reset qstack
in smtlib2_noll_parser_set_logic: set-logic QF_S
in smtlib2_noll_parser_declare_sort: register record Sll_t.
make_sort start: Sll_t
make_sort start: Sll_t
in smtlib2_noll_parser_declare_function: mk_fun_decl (variable or field) next.
make_sort start: Sll_t
push_quant start: 
ctx = [pname => (null),
	lvar_stack => [1,
	]
	lvar_env => 1
	svar_stack=[0,
	]
	svar_env => 0
]
mk_symbol: start ?in
mk_symbol: local ?in (id 1)
make_sort start: Sll_t
mk_symbol: start ?out
mk_symbol: local ?out (id 2)
make_sort start: Space
mk_symbol: start ?in
mk_symbol: local ?in (id 1)
mk_symbol: start ?out
mk_symbol: local ?out (id 2)
make_sort start: Sll_t
push_quant start: 
ctx = [pname => (null),
	lvar_stack => [1,2,
	]
	lvar_env => 3
	svar_stack=[0,0,
	]
	svar_env => 0
]
mk_symbol: start ?X
mk_symbol: local ?X (id 3)
mk_symbol: start ?in
mk_symbol: local ?in (id 1)
mk_symbol: start ?out
mk_symbol: local ?out (id 2)
mk_symbol: start ?in
mk_symbol: local ?in (id 1)
mk_symbol: start next
mk_symbol: start ?X
mk_symbol: local ?X (id 3)
mk_symbol: start ?X
mk_symbol: local ?X (id 3)
mk_symbol: start ?out
mk_symbol: local ?out (id 2)
mk_exists start lvar_stack=[1,2,1,]
mk_exists exists lvar=[?X,]
mk_exists start svar_stack=[0,0,0,]
mk_exists exists svar=[]
pop_quant start: ctx = [pname => ls,
	lvar_stack => [1,2,1,
	]
	lvar_env => 4
	svar_stack=[0,0,0,
	]
	svar_env => 0
]
pop_quant end: ctx = [pname => ls,
	lvar_stack => [1,2,
	]
	lvar_env => 3
	svar_stack=[0,0,
	]
	svar_env => 0
]
pred_rule_base ctx: ctx = [pname => ls,
	lvar_stack => [1,2,
	]
	lvar_env => 3
	svar_stack=[0,0,
	]
	svar_env => 0
]
pred_rule_rec ctx: ctx = [pname => ls,
	lvar_stack => [1,2,
	]
	lvar_env => 3
	svar_stack=[0,0,
	]
	svar_env => 0
]
pred_rule_rec quant.lvars: 
local vars: [ nil:void, ??in:Sll_t, ??out:Sll_t, ??X:Sll_t,  - ]
noll_type_match: fty=3, atyp=3
noll_type_match: fty=rec-1, atyp=rec-1
in smtlib2_noll_parser_define_function: register function ls.
pop_quant start: ctx = [pname => (null),
	lvar_stack => [1,2,
	]
	lvar_env => 3
	svar_stack=[0,0,
	]
	svar_env => 0
]
pop_quant end: ctx = [pname => (null),
	lvar_stack => [1,
	]
	lvar_env => 1
	svar_stack=[0,
	]
	svar_env => 0
]
make_sort start: Sll_t
in smtlib2_noll_parser_declare_function: mk_fun_decl (variable or field) x_emp.
make_sort start: Sll_t
in smtlib2_noll_parser_declare_function: mk_fun_decl (variable or field) y_emp.
make_sort start: Sll_t
in smtlib2_noll_parser_declare_function: mk_fun_decl (variable or field) z_emp.
make_sort start: SetLoc
in smtlib2_noll_parser_declare_function: mk_fun_decl (variable or field) alpha0.
mk_symbol: start x_emp
mk_symbol: local x_emp (id 1)
mk_symbol: start next
mk_symbol: start y_emp
mk_symbol: local y_emp (id 2)
mk_symbol: start y_emp
mk_symbol: local y_emp (id 2)
mk_symbol: start next
mk_symbol: start z_emp
mk_symbol: local z_emp (id 3)
Push positive formula:
 (tobool 
	 (ssep 
	 (pto  x_emp 
	 (ref  next 
	 y_emp 
	 )

	 )

	 (pto  y_emp 
	 (ref  next 
	 z_emp 
	 )

	 )

	 )

	 )

with context: 
lvars: [ nil:void,  x_emp:Sll_t,  y_emp:Sll_t,  z_emp:Sll_t,  - ]
noll_exp_push_top:
	
lvars: [ nil:void,  x_emp:Sll_t,  y_emp:Sll_t,  z_emp:Sll_t,  - ]
	
svars: [ alpha0:SetLoc,  - ]
in smtlib2_noll_parser_assert_formula: parser a formula.
mk_symbol: start alpha0
mk_symbol: local alpha0 (id 0)
mk_symbol: start x_emp
mk_symbol: local x_emp (id 1)
mk_symbol: start z_emp
mk_symbol: local z_emp (id 3)
Push negative formula:
 (tobool 
	 (index  alpha0 
	 (ls  x_emp 
	 z_emp 
	 )

	 )

	 )

with context: 
lvars: [ nil:void,  x_emp:Sll_t,  y_emp:Sll_t,  z_emp:Sll_t,  - ]
noll_exp_push_top:
	
lvars: [ nil:void,  x_emp:Sll_t,  y_emp:Sll_t,  z_emp:Sll_t,  - ]
	
svars: [ alpha0:SetLoc,  - ]
noll_type_match: fty=3, atyp=3
noll_type_match: fty=rec-1, atyp=rec-1
in smtlib2_noll_parser_assert_formula: parser a formula.
in smtlib2_noll_parser_check_sat: check-sat.
*** (source samples/ls/ls-en-01.smt) check-sat on:

records:: [ void (), Sll_t (next;), - ]
fields:: [ next:Sll_t->Sll_t (-1-th, in pid--1), - ]
predicates:: [pred-0: ls(2 args) of type NULL
of rules 
rule: 
exists : [ nil:void, ??in:Sll_t, ??out:Sll_t,  - ]. 
	(pure) nil=nil, nil#?in, nil#?out, ?in=?in, ?in=?out, ?out=?out, null


	 & (pto) [precise] emp
	  * (nst) (null) emp

	  * (rec) (null) emp

rule: 
exists : [ nil:void, ??in:Sll_t, ??out:Sll_t, ??X:Sll_t,  - ]. 
	(pure) nil=nil, nil#?in, nil#?out, nil#?X, ?in=?in, ?in<>?out, ?in#?X, ?out=?out, ?out#?X, ?X=?X, null


	 & (pto) [precise] (pto  ?in (next ?X) )
	  * (nst) (null) emp

	  * (rec) [precise] (ssep [precise] (ls_*-1 ?X  ?out )
	)
 - ]
Formula 1: sat

	 lvars: 
lvars: [ nil:void,  x_emp:Sll_t,  y_emp:Sll_t,  z_emp:Sll_t,  - ]
	 svars: 
svars: [ alpha0:SetLoc,  - ]
	 pure part: null

	 shape part: [precise] (ssep [precise] (pto  x_emp (next y_emp) )
	[precise] (pto  y_emp (next z_emp) )
	)
	 share part: true

Formulae 0: 
\/ (0-0): sat

	 lvars: 
lvars: [ nil:void,  x_emp:Sll_t,  y_emp:Sll_t,  z_emp:Sll_t,  - ]
	 svars: 
svars: [ alpha0:SetLoc,  - ]
	 pure part: null

	 shape part: [precise] (ls_alpha0 x_emp  z_emp )
	 share part: true
Field next @(pid = 0, kind = 1) order=0

Total time (sec): 0.073599

unsat
